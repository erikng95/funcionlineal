/************************************************************************/
/* Parser.c                                                             */
/*                                                                      */
/************************************************************************/
//=============================================================================================================================================//
Funcionamiento com_B(void)    //Dibujar un rectangulo

- Leer largo,ancho,grosor desde el buffer
- Si grosor es 0 y largo/ancho < grosor, terminar funcion.
- Dibujar linea horizontal.
- Dibujar linea vertical, mover x, dibujar segunda linea vertical.
- Mover y, dibujar linea horizontal.
   
//=============================================================================================================================================//

Para hacer el codigo dibdiag me he basado en diblin.

//=============================================================================================================================================//
/************************************************************************/
/* Imagen.c                                                             */
/*                                                                      */
/************************************************************************/
//=============================================================================================================================================//
Funcionamiento diblin(int l,int g)

Variables de entrada: "l" es el numero de bits en una linea, "g" es el numero de repeticion de lineas.
- Asignar el banco RAM(2).
- Inicializar valores "x" e "y" segun "h_pos" y "v_pos". Si hay rotacion, nuevos valores de "x","y" y/o intercambio de valores de "l" y "g".
- Calcular la posicion del primer bit("nbit") para calcular la mascara inicial. 
- Si se pasa de la memoria, cambio de memoria(BANCO_IRAM+1) y calcular nueva "y".
- Inicializar pointer segun el valor "x","y".
- Calcular numero de bits sin el primer byte("n"), para saber cuantos bytes intermedios("m") hay.
- Calcular mascara inicial (segun "nbit") y mascara final(segun "n"%8).
- Bucle en y (segun el grosor, a menos que haya una rotacion)
    - Si el flag de etiqueta en blanco esta subida, poner todos los bytes a 0.
    - Aplicar mascara del primer byte.
    - Pointer1 segun el valor de pointer.
    - Si hay bytes intermedios("m">0)
        Bucle X:
        - Incrementar Pointer 1.
        - *Pointer 1 rellenar el byte de 1s (0xFF)
    - Si hay bits en el ultimo byte, incrementar Pointer1 y aplicar mascara final(masc2).
    - Pasar a la siguiente linea(ptr += bytlin), segun el valor de g; repetir los pasos anteriores.
    - Atizar WDG;
    - Monitor;
- Desasignar el banco RAM.    
    
//=============================================================================================================================================//

//=============================================================================================================================================//
Funcionamiento dibdiag(int l,int anch,int g)

Variables de entrada: "l" es el numero de bits en una linea,"anch" es necesario cuando hay una rotacion ,"g" es el numero de repeticion de lineas.
- Asignar el banco RAM(2).
- Inicializar valores "x" e "y" segun "h_pos" y "v_pos". Si hay rotacion, calcular nuevos valores de "x" e "y" y/o cambiar el valor de "l" por "a".
- Calcular la posicion del primer bit("nbit") para bucle.
- Calcular pendiente segun el largo y ancho de la linea. 
- Si se pasa de la memoria, cambio de memoria(BANCO_IRAM+1) y calcular nueva "y".
- Inicializar pointer segun el valor "x" e "y".
- Bucle en y (segun el grosor)
    - Si el flag de etiqueta en blanco esta subida, poner todos los bytes a 0.
    - Pointer1 segun el valor de pointer.
    - Inicializar "m" con el valor de la posicion del primer bit. ("m"="nbit")
    - Inicializar "punt_ant" inicio de la linea.("punt_ant" = 0)
    - Numero de bits en "l"
        Bucle X:
        - Calcular punto del bit actual segun la funcion lineal.
        - Si "punt-punt_ant" es mayor que 1, calcular puntos intermedios(para que no haya espacios vacios en la linea).
        - Actualizar "punt_ant" = "punt" para sacar el diferencial con el siguiente punto.
        - Pasar a la siguiente(s) linea(s) segun el diferencial de "punt-punt_ant".(ptr1 +=bytlin)
        - Si el bit actual esta en el mismo byte que el anterior bit, no mover Pointer1.
        - Si el bit actual esta en el siguiente byte, incrementar Pointer1.
        - Segun el valor de "m" (posicion del bit actual) calcular mascara.
        - Incrementar "m";
        - Aplicar mascara al *Pointer1.
    - Pasar a la siguiente linea(ptr += bytlin), segun el valor de g; repetir los pasos anteriores.
    - Atizar WDG;
    - Monitor;
- Desasignar el banco RAM.    
    
//=============================================================================================================================================//


    Datos que se mandan a la funcion de dibujar diagonal:
        Posicion X  (h_pos)
        Posicion Y  (v_pos)
        Largo       (x)
        Ancho       (y)
        Grosor      (g)


-Calculo de puntos mediante la funcion lineal:

     Yfin - Yini
 a = ----------
     Xfin - Xini
 
 b = Yini - (a * Xini)    
 
 f(x) = ax + b
Notas:
-Bucle tiene que ir de bit en bit, en vez de bytes.
-Nuevas tablas para la mascara, la mascara cambia cada bit:

tblmasd[8] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01} 

1000 0000 | 0100 0000 | 0010 0000 | 0001 0000 | 0000 1000 | 0000 0100 | 0000 0010 | 0000 0001

-Comprobar si el bit esta en el mismo byte que el anterior.

Pruebas:
funcion lineal
mascaras
pasar de byte

Dudas:

//=============================================================================================================================================//

     if (yy >= 0x20000)
       {
       selbnk();
       yy -= 0x20000;
       ptr = (char *) IMAGEN;
       ptr += yy;
       ptr += 32;
       }
  Cambia de ram (BANCO_IRAM+1)
  Resta 0x20000 a yy
  ptr apunta a la nueva RAM
  ptr se le suma el valor de yy
  ptr se le suma 32 (4 bytes ?)
       
//=============================================================================================================================================//

- Coeficiente b siempre es 0, igual no hace falta la funcion calc_b. Hay que a√±adir offset X y offset Y 

- No se si usar ints o uchars 
- funcion de uchar f 
- "yy" e "yyy" sirven para saber si el pointer se ha pasado a otra memoria (?)